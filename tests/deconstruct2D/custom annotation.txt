	// .globl	chpl_gpu_kernel_test_line_44_
.visible .entry chpl_gpu_kernel_test_line_44_(
	.param .u64 chpl_gpu_kernel_test_line_44__param_0,
	.param .u64 chpl_gpu_kernel_test_line_44__param_1,
	.param .u64 chpl_gpu_kernel_test_line_44__param_2,
	.param .u64 chpl_gpu_kernel_test_line_44__param_3,
	.param .u64 chpl_gpu_kernel_test_line_44__param_4
)
{
	.reg .pred 	%p<4>;										//Setting registers
	.reg .b32 	%r<4>;
	.reg .b64 	%rd<40>;
	.reg .f64 	%fd<2>;

1	ld.param.u64 	%rd16, [chpl_gpu_kernel_test_line_44__param_0];					//loading consts or global vars
2	ld.param.u64 	%rd18, [chpl_gpu_kernel_test_line_44__param_1];
3	mov.u32 	%r1, %ctaid.x;									// assign CTA identifier within a grid	to reg1				
4	mov.u32 	%r2, %ntid.x;									// assign Number of thread IDs per CTA to reg2			
5	mov.u32 	%r3, %tid.x;									// assign thread ID to reg3
6	mul.wide.s32 	%rd21, %r1, %r2;								// multiply lines 3 and 4 (ctaid and ntid) into reg3 (signed multiply op)in reg21
7	cvt.s64.s32 	%rd22, %r3;									// Convert a value from one type to another (thread id, reg3) from signed32 to s64, in reg22
8	add.s64 	%rd23, %rd21, %rd22;								// Add values from reg 22 and 21 into 
9	add.s64 	%rd4, %rd23, %rd16;								// Add previous value with param_1 into reg4
10	setp.gt.s64 	%p1, %rd4, %rd18;								// Compare two numeric values with a relational operator, 'greater than', store in reg predicate1
11	@%p1 bra 	$L__BB25_4;									// branch if param1 is greater than r4 ( ctaid * ntid + tid), branch to line 46
12	ld.param.u64 	%rd20, [chpl_gpu_kernel_test_line_44__param_2];					// load param2 to r20
13	cvta.to.global.u64 	%rd3, %rd20;								// convert param2 from u64 to global address space
14	ld.global.u64 	%rd5, [%rd3+88];							reg5	// load off set of 11 bytes of param2 into reg5
15	ld.global.u64 	%rd6, [%rd3+96];							reg6	// load off set of 12 bytes of param2 into reg6
16	setp.gt.s64 	%p2, %rd5, %rd6;							p2	// compare the two global values
17	@%p2 bra 	$L__BB25_4;									// branch to lines 46 (the end) if reg5 greater than reg6
18	ld.param.u64 	%rd17, [chpl_gpu_kernel_test_line_44__param_4];				reg17	// load param 4 into reg 17
19	cvta.to.global.u64 	%rd1, %rd17;							reg1	//convert into global value in reg 3
20	ld.param.u64 	%rd19, [chpl_gpu_kernel_test_line_44__param_3];				reg19	// load param 3 into reg 19
21	cvta.to.global.u64 	%rd2, %rd19;							reg2	// convert into global value in reg 2
22	ld.global.u64 	%rd24, [%rd2+8];							reg24	// load param 3 offset of 1 byte into into reg 24
23	ld.u64 	%rd25, [%rd24+96];								reg25	// load the previous value with another 13 byte offset
24	mul.lo.s64 	%rd26, %rd25, %rd4;							reg26	// multiply previous value with reg 4 containing (ctaid * ntid + tid)
25	ld.u64 	%rd27, [%rd24+176];								reg27	// load line 22 value with 22byte offset
26	ld.global.u64 	%rd28, [%rd1+8];							reg28	// load param 4 from global memory with 1 byte offset
27	ld.u64 	%rd29, [%rd28+96];								reg29	// load previous value with 12byte offset
28	mul.lo.s64 	%rd30, %rd29, %rd4;							reg30	// multiply previous with reg 4 containing (ctaid * ntid + tid), saving only the lowest 64bits
29	ld.u64 	%rd31, [%rd28+176];								reg31	// load value from line 26 with 22byte offset
30	sub.s64 	%rd32, %rd6, %rd5;							reg32	// subtract line 14 from line 15
31	add.s64 	%rd39, %rd32, 1;							reg39	// add one to previous value in reg 32
32	add.s64 	%rd33, %rd5, %rd30;							reg33	// add line 28 value to reg 5
33	shl.b64 	%rd34, %rd33, 3;							reg 34  // logical shift left of reg 33 by 3
34	add.s64 	%rd38, %rd31, %rd34;							reg 38  // add line 28 and line 33 values
35	add.s64 	%rd35, %rd5, %rd26;							reg 35  // add line 14 and line 24 values
36	shl.b64 	%rd36, %rd35, 3;							reg 36  // logical shift left of reg 35
37	add.s64 	%rd37, %rd27, %rd36;							reg 37  // add line 25 and line 36 values
38    $L__BB25_3:
39	ld.f64 	%fd1, [%rd38];									fd1     // load into memory using address at line 34 value into fd1 as a floating point
40	st.f64 	[%rd37], %fd1;									memory  // store value in fd1 into memory at address in reg37
41	add.s64 	%rd39, %rd39, -1;							reg 39  // subtract reg 39 (line 31) value by 1
42	add.s64 	%rd38, %rd38, 8;							reg 38  // add 8 to reg 38 
43	add.s64 	%rd37, %rd37, 8;							reg 37  // add 8 to reg 37
44	setp.ne.s64 	%p3, %rd39, 0;								// compare to see if reg 39 is smaller than 0
45	@%p3 bra 	$L__BB25_3;								// if so jump to line 38
46    $L__BB25_4:
47	ret;

}
	// .globl	chpl_gpu_kernel_test_line_44_2
.visible .entry chpl_gpu_kernel_test_line_44_2(
	.param .u64 chpl_gpu_kernel_test_line_44_2_param_0,
	.param .u64 chpl_gpu_kernel_test_line_44_2_param_1,
	.param .u64 chpl_gpu_kernel_test_line_44_2_param_2,
	.param .u64 chpl_gpu_kernel_test_line_44_2_param_3,
	.param .u64 chpl_gpu_kernel_test_line_44_2_param_4,
	.param .u64 chpl_gpu_kernel_test_line_44_2_param_5,
	.param .u64 chpl_gpu_kernel_test_line_44_2_param_6
)
{
	.reg .pred 	%p<2>;
	.reg .b32 	%r<4>;
	.reg .b64 	%rd<26>;
	.reg .f64 	%fd<2>;

	ld.param.u64 	%rd7, [chpl_gpu_kernel_test_line_44_2_param_0];
	ld.param.u64 	%rd9, [chpl_gpu_kernel_test_line_44_2_param_1];
	mov.u32 	%r1, %ctaid.x;
	mov.u32 	%r2, %ntid.x;
	mov.u32 	%r3, %tid.x;
	mul.wide.s32 	%rd13, %r1, %r2;
	cvt.s64.s32 	%rd14, %r3;
	add.s64 	%rd15, %rd13, %rd14;
	add.s64 	%rd5, %rd15, %rd7;
	setp.gt.s64 	%p1, %rd5, %rd9;
	@%p1 bra 	$L__BB26_2;
	ld.param.u64 	%rd6, [chpl_gpu_kernel_test_line_44_2_param_2];
	ld.param.u64 	%rd8, [chpl_gpu_kernel_test_line_44_2_param_6];
	cvta.to.global.u64 	%rd1, %rd8;
	ld.param.u64 	%rd10, [chpl_gpu_kernel_test_line_44_2_param_5];
	cvta.to.global.u64 	%rd2, %rd10;
	ld.param.u64 	%rd11, [chpl_gpu_kernel_test_line_44_2_param_4];
	cvta.to.global.u64 	%rd3, %rd11;
	ld.param.u64 	%rd12, [chpl_gpu_kernel_test_line_44_2_param_3];
	cvta.to.global.u64 	%rd4, %rd12;
	ld.global.u64 	%rd16, [%rd4+96];
	mul.lo.s64 	%rd17, %rd16, %rd6;
	add.s64 	%rd18, %rd17, %rd5;
	shl.b64 	%rd19, %rd18, 3;
	add.s64 	%rd20, %rd3, %rd19;
	ld.global.u64 	%rd21, [%rd2+96];
	mul.lo.s64 	%rd22, %rd21, %rd6;
	add.s64 	%rd23, %rd22, %rd5;
	shl.b64 	%rd24, %rd23, 3;
	add.s64 	%rd25, %rd1, %rd24;
	ld.global.f64 	%fd1, [%rd25];
	st.global.f64 	[%rd20], %fd1;
$L__BB26_2:
	ret;